<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; The Lambda Origin</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./chapter_02.html" rel="next">
<link href="./index.html" rel="prev">
<link href="./notebooks/images/favicon.ico" rel="icon">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-707d8167ce6003fca903bfe2be84ab7f.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-3201250c3049d367e50c9b8f56559e13.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./chapter_01.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Lambda Origin</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Parens From The Past</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_01.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Lambda Origin</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">chapter_02.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">chapter_03.html</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./chapter_04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">chapter_04.html</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Lambda Origin</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<style></style>
<style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style>
<style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script>
<script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script>
<hr>
<blockquote class="blockquote">
<p><em>Princeton, 1932. In a quiet office at the mathematics department,</em></p>
<p><img alt="Alonzo Church" src="notebooks/images/Alonzo_Church.webp" height="100"> <strong>Alonzo Church</strong> <em>sat at his desk, scribbling notations that would one day change the world of computation. He was developing a formal system of mathematical logic based on functions and abstractions rather than numbers and operations. The</em> <strong>lambda calculus</strong> <em>was being born.</em></p>
<p><em>He wrote:</em> <code>λx.x</code> <em>a simple identity function. Four symbols that capture the essence of function itself: input becomes output, cause becomes effect. Church couldn’t have known that decades later, these abstractions would help shape programming languages that would power everything from space shuttles to smartphones.</em></p>
<p><em>Twenty-five years after Church’s work,</em></p>
<p><img alt="John McCarthy" src="notebooks/images/John-McCarthy.webp" height="100"> <strong>John McCarthy</strong> <em>would take inspiration from the</em> <strong>lambda calculus</strong> <em>to create</em> <strong>LISP</strong> <em>, introducing parentheses as the iconic delimiter, the container that would say: within these bounds, transformation occurs.</em></p>
<p><em>And then, half a century after McCarthy,</em></p>
<p><img alt="Rich Hickey" src="notebooks/images/rich-hickey.webp" height="100"> <strong>Rich Hickey</strong> <em>would sit at his own desk and think:</em></p>
<p><em>what if we made parentheses not just syntax, but semantics?</em></p>
</blockquote>
<hr>
<p>Alex paused, considering the irony. Here he was, implementing a poor excuse for a persistent data structure when Clojure had already perfected them. But this wasn’t for Clojure. This was for a world that couldn’t afford Clojure’s luxuries, the realm of embedded systems where he had begun his journey half a century ago.</p>
<p>A mutable place to store memories, in Clojure:</p>
<div class="sourceClojure">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode clojure code-with-copy"><code class="sourceCode clojure"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> memories </span>(<span class="kw">atom</span> {}))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>The mechanical engineering degree he’d earned in ’79 had been his foundation, but it was that single FORTRAN class that had altered the trajectory of his life. Punch cards and mainframes, primitive by today’s standards, yet they’d opened a door he never wanted to close.</p>
<p>The origin of a rewarding career, in Clojure:</p>
<div class="sourceClojure">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode clojure code-with-copy"><code class="sourceCode clojure"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">swap!</span> memories <span class="kw">assoc</span> <span class="at">:origin</span> {<span class="at">:year</span> <span class="dv">1979</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                               <span class="at">:language</span> <span class="st">"FORTRAN"</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                               <span class="at">:medium</span> <span class="st">"punch cards"</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                               <span class="at">:machine</span> <span class="st">"mainframe"</span>})</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="printedClojure">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode clojure code-with-copy"><code class="sourceCode clojure"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>{<span class="at">:origin</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a> {<span class="at">:year</span> <span class="dv">1979</span>,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">:language</span> <span class="st">"FORTRAN"</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">:medium</span> <span class="st">"punch cards"</span>,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">:machine</span> <span class="st">"mainframe"</span>}}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>His smartphone chimed. A calendar reminder: “Meeting with Kai, Elena, and Raj – 8:00 AM.”</p>
<p>Alex took a sip of his coffee, black and bitter like the APL syntax he’d learned at his first job. He remembered how impressive it was that, instead of submitting FORTRAN punch cards to be compiled on the mainframe and getting back a printout, he could write APL programs interactively on an IBM Selectric teletypewriter. Wow, my first REPL, he thought. Then it dawned on him that APL had been his first laconic programming language, so laconic, in fact, that Conway’s Game Of Life can be implemented in one line of APL code, albeit write-only:</p>
<hr>
<blockquote class="blockquote">
<pre><code>⍝ Conway's Game of Life In One Line Of APL Code
Z←(3=M+.×(¯1 0 1∘.×¯1 0 1))∨(M∧2=M+.×(¯1 0 1∘.×¯1 0 1))</code></pre>
</blockquote>
<hr>
<p>Alex still remembered the thrill of implementing his own FORTH system, called TIL, at that first job. He realized that FORTH was his second laconic language, and it had a REPL too. He had used TIL’s FORTH dialect to write the maintenance software for the manufacturing machine that was controlled by a small-refrigerator-size IBM Series/1 minicomputer, then had implemented TIL again for a Zilog Z80 single-board machine control computer. The constraints of those systems had demanded ingenuity and perseverance.</p>
<hr>
<blockquote class="blockquote">
<pre class="forth"><code>\ Create a FORTH "word" named "2DOUBLE", and use it
: 2DOUBLE ( a b -- a b 2*a 2*b ) swap over 2 * over 2 * ;

1 2 2DOUBLE .s &lt;4&gt; 2 1 4 2 ok          </code></pre>
</blockquote>
<hr>
<p>That was the time when his colleague, Dave the astrophysicist who had written the PDP-11 FORTH control system for the Multiple Mirror Telescope outside Tucson, had introduced him to FORTH.</p>
<p><img alt="TIL" src="notebooks/images/threaded-interpretive-languages.webp" height="200"> “Threaded Interpretive Languages,” Alex murmured, remembering the BYTE book that had changed everything. He’d implemented FORTH in assembler for both the IBM Series/1 minicomputer, and the Zilog Z80 single-board computer, and later, with Dave, a meta-FORTH system for a Motorola 68000 minicomputer that could target FORTH systems for other computers.</p>
<p>That meta-FORTH was used to implement a Unix-like operating system for both the IBM PC and the Amiga. That had been a time of pure creation, when possibility seemed endless and hardware constraints were just puzzles waiting to be solved.</p>
<p>The path from FORTH to Clojure, in Clojure</p>
<div class="sourceClojure">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode clojure code-with-copy"><code class="sourceCode clojure"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">swap!</span> memories <span class="kw">assoc</span> <span class="at">:career-path</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>       [{<span class="at">:era</span> <span class="st">"1980s"</span>,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">:focus</span> <span class="st">"Embedded Systems, APL, FORTH, Meta-FORTH"</span>}</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        {<span class="at">:era</span> <span class="st">"1990s"</span>,</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>         <span class="at">:focus</span> <span class="st">"Modula-2, Ada, Pascal, Database Development"</span>}</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        {<span class="at">:era</span> <span class="st">"2000s"</span>,</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>         <span class="at">:focus</span> <span class="st">"Cyber Security Startup, Acquisition"</span>}</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        {<span class="at">:era</span> <span class="st">"2010s"</span>,</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>         <span class="at">:focus</span> <span class="st">"Clojure, C++, Embedded Systems, Scale Indicators"</span>}</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        {<span class="at">:era</span> <span class="st">"2020s"</span>,</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>         <span class="at">:focus</span> <span class="st">"Clojure, Modern C++, Embedded Systems"</span>}])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="printedClojure">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode clojure code-with-copy"><code class="sourceCode clojure"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>{<span class="at">:origin</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a> {<span class="at">:year</span> <span class="dv">1979</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">:language</span> <span class="st">"FORTRAN"</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">:medium</span> <span class="st">"punch cards"</span>,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">:machine</span> <span class="st">"mainframe"</span>},</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a> <span class="at">:career-path</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a> [{<span class="at">:era</span> <span class="st">"1980s"</span>, <span class="at">:focus</span> <span class="st">"Embedded Systems, APL, FORTH, Meta-FORTH"</span>}</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  {<span class="at">:era</span> <span class="st">"1990s"</span>, <span class="at">:focus</span> <span class="st">"Modula-2, Ada, Pascal, Database Development"</span>}</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  {<span class="at">:era</span> <span class="st">"2000s"</span>, <span class="at">:focus</span> <span class="st">"Cyber Security Startup, Acquisition"</span>}</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  {<span class="at">:era</span> <span class="st">"2010s"</span>,</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>   <span class="at">:focus</span> <span class="st">"Clojure, C++, Embedded Systems, Scale Indicators"</span>}</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  {<span class="at">:era</span> <span class="st">"2020s"</span>, <span class="at">:focus</span> <span class="st">"Clojure, Modern C++, Embedded Systems"</span>}]}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Alex glanced at his career path encoded in Clojure’s data structures. It was cleaner this way, more elegant than the tangled mess of reality. His journey from college FORTRAN, to APL, to FORTH-based embedded systems, to high-performance embedded relational database internals, to a cyber security startup, to Principal Engineer after acquisition, and finally to his current “retirement job”, it all looked so logical in retrospect. Even being laid off at 60 years old, which had felt devastating at the time, had led him back to embedded systems at an OEM company that manufactures weighing equipment.</p>
<p>Full circle. There was beauty in that symmetry.</p>
<p>Alex pulled up his prototype C++ code again. It wasn’t much, but it was a start. He had implemented a simple C++ persistent vector that avoided heap allocations and exceptions, making it suitable for embedded systems. It used copying, along with C++ Return Value Optimization (RVO) for performance, instead of structural sharing like Clojure, which was less efficient for large collections but perfectly reasonable for the small data sets typical in embedded applications.</p>
<p>The Zoom interface loaded on his screen. Three faces appeared, each in their own quadrant: Kai in Frankfurt, Elena from her apartment in New York, and Raj connecting from Bangalore. Three decades separated Alex from the youngest of them. Three decades of technological evolution, trials and errors, raising a family, and a great deal of soul searching.</p>
<p>“Morning, Alex,” Kai greeted, his German accent faint but discernible. At thirty-five, Kai was the C++ specialist, the one who understood the latest incarnation of a language that accretes features like a snowball rolling down a hill. With his shaved head and forearm tattoos that peeked out from under his rolled-up sleeves, Kai looked more like a punk musician than an embedded systems developer who specialized in medical devices.</p>
<hr>
<blockquote class="blockquote">
<p><strong>Accrete</strong> &nbsp; &nbsp; /əˈkriːt/ &nbsp; &nbsp; <em>verb</em></p>
<p>To grow or increase gradually by the addition of material.</p>
<p>Used in the Clojure community to describe:</p>
<ul>
<li>a philosophy of software evolution that emphasizes gradual, non-destructive growth over mutation or breaking changes, and</li>
<li>how Clojure’s persistent data structures evolve by adding new data without modifying existing structures.</li>
</ul>
</blockquote>
<hr>
<p>“How’s our oldest and wisest team member today?” Elena asked with a smile. Her background in linguistics made her the perfect ClojureScript expert, understanding the semantics of code in ways that transcended syntax. At thirty-three, she had already published papers on the computational theory of linguistic meaning and had been one of the early advocates for ClojureScript’s approach to frontend development.</p>
<p>“I’ve been thinking about our approach,” Alex said, ignoring the gentle tease about his age. “I was up half the night implementing a prototype.”</p>
<p>Raj, the mathematics wizard with an almost religious devotion to clojure.core.logic, raised an eyebrow. “You didn’t have to do that alone.” At twenty-eight, Raj was the youngest and perhaps the most brilliant of them all, currently working on a PhD in computational mathematics at Technische Universität (TU) Darmstadt when he wasn’t obsessing over logic programming and constraint satisfaction problems.</p>
<p>“Old habits,” Alex replied. “When you’ve spent decades coding through the night, it becomes a form of meditation.”</p>
<p>Alex shared his screen, revealing the C++ implementation he’d been working on.</p>
<p>“This is just a starting point,” Alex explained. “I’m using copying instead of structural sharing, but for small collections on embedded systems, it’s a reasonable trade-off.”</p>
<p>Kai examined the code, nodding. “I see what you’re doing. No dynamic allocation, no exceptions, and it’s all <code>constexpr</code>-friendly. But we’ll need to think about the performance implications of copying.”</p>
<p>“That’s where you come in,” Alex said. “I know the Clojure side, but you understand the nuances of modern C++. Together, we can create something that brings Clojure’s elegance to environments that can’t support a runtime.”</p>
<p>Elena leaned forward. “Cljonic,” she said suddenly. “That’s what we should call it.”</p>
<p>“Cljonic?” Raj repeated.</p>
<p>“It’s perfect,” Elena insisted. “It combines ‘Clojure’ with ‘laconic’, expressing much in few words. That’s what we’re trying to build, right? A concise, expressive library for C++ that captures Clojure’s spirit.”</p>
<p>Alex smiled. The name resonated with him. After all, wasn’t that what had drawn him to APL and FORTH all those years ago, and later to Clojure? The ability to express complex ideas with elegant simplicity?</p>
<p>“Cljonic it is,” he agreed. “A bridge between worlds, the functional elegance of Clojure and the bare-metal efficiency of C++.”</p>
<p>“But why now?” Raj asked, his hands gesturing animatedly. “There are already C++ libraries with functional features. Ranges, views, algorithms… C++20 has a lot of this built in.”</p>
<p>“Those features are great,” Alex acknowledged, “but they’re not designed specifically for embedded systems. Most embedded developers I’ve worked with don’t have time to keep up with the latest C++ features. They’re self-taught, learning on the job. They need something that’s easy to learn and use properly. And they need to be able to prototype ideas in Clojure on a big-computer.”</p>
<p>“And most embedded systems can’t use the heap or exceptions,” Kai added. “So many modern C++ features are off-limits.”</p>
<p>“Exactly,” Alex said. “That’s where Cljonic comes in. We’re targeting embedded systems that can’t use dynamic allocation but still need the benefits of immutability and functional programming. Safe code that’s easy to read, understand, and maintain.”</p>
<p>Elena nodded. “I like the approach. We’re not trying to replace Clojure or compete with C++’s standard library. We’re creating a bridge for a specific domain.”</p>
<p>“But we need to be careful about performance,” Raj cautioned. “Copying everything will be expensive.”</p>
<p>“That’s true,” Alex agreed, “but we’re targeting small collections. And many embedded projects have plenty of non-performance-critical code where safety and maintainability are more important than raw speed.”</p>
<p>Kai scratched his chin thoughtfully. “We could add some optimizations. Maybe use small buffer optimization techniques for collections, or add a way to specify a custom allocator for systems that can use some forms of controlled allocation.”</p>
<p>“Good ideas,” Alex said. “But let’s start simple and expand from there.”</p>
<p>“We should define our goals clearly,” Elena suggested. “What exactly are we trying to achieve with Cljonic?”</p>
<p>Alex thought for a moment. “I think our primary goal should be to bring Clojure’s philosophy to C++ embedded systems. That means immutability by default, pure functions where possible, and a focus on data transformations rather than state mutations.”</p>
<p>“And it should be header-only,” Kai added. “No build system complexity.”</p>
<p>“Bounded collection sizes,” Raj contributed. “No dynamic growth, but configurable maximum sizes.”</p>
<p>“Default values instead of exceptions,” Elena said. “If you try to access an element that doesn’t exist, you get a sensible default rather than a crash or an error code.”</p>
<p>Alex nodded, impressed by how quickly they were coalescing around a shared vision. “This is good. Very good. Let me add one more: everything should be <code>constexpr</code> whenever possible. That way, we can catch errors at compile time and enable compile-time evaluation.”</p>
<p>Kai’s eyes lit up. “That’s a great goal. Modern C++ compilers can do amazing things with <code>constexpr</code>.”</p>
<p>“So we’re agreed,” Alex said. “Cljonic will be a header-only, embedded-systems-focused C++ library that brings Clojure’s functional programming style to environments that can’t use the heap or exceptions. It will be immutable by default, with bounded collections, default values, and extensive use of <code>constexpr</code>.”</p>
<p>“What should we implement first?” Raj asked.</p>
<p>“I’ve started with a persistent vector, otherwise called a vector in Clojure,” Alex said, “but we should think about what other data structures we need.”</p>
<p>“Maps, definitely,” Elena said. “Clojure’s immutable maps are incredibly useful.”</p>
<p>“And some form of sequences or lazy evaluation,” Raj added.</p>
<p>“Function composition, partial application and transducers would be nice,” Kai suggested.</p>
<p>Alex smiled. “Ambitious. I like it. But let’s start with the simplest core data structures: set, string, range, repeat, and vector. Once we have those, we can build on them, and then tackle maps.”</p>
<p>They spent the next hour outlining the API for Cljonic’s core data structures. Alex found himself energized by the collaboration, by the blend of perspectives and expertise. Kai’s deep knowledge of modern C++, Elena’s understanding of language design, Raj’s mathematical precision, all of it complemented Alex’s decades of experience in embedded systems, and his autistic tendency to think outside the box.</p>
<p>As they wrapped up, Alex shared a thought that had been brewing: “You know, what we’re doing here is more than just creating a library. We’re bringing a philosophy, a way of thinking about code, to a domain that hasn’t been exposed to it much. Clojure changed how I think about programming. Maybe Cljonic can do the same for embedded developers.”</p>
<p>“That’s quite a goal,” Elena said, but her tone was encouraging rather than dismissive.</p>
<p>“Maybe,” Alex admitted. “But I’ve seen what happens when developers are exposed to functional programming for the first time. It’s like a light bulb goes on. Suddenly, they see solutions they couldn’t see before.”</p>
<p>“I had that experience with Clojure,” Raj said. “It was like learning to think in a new dimension.”</p>
<p>“Exactly,” Alex said. “That’s what I want to bring to the embedded world. Not just a library, but a new way of thinking.”</p>
<p>“Then let’s make it happen,” Kai said, his pragmatic nature asserting itself. “I’ll start on a proper implementation of the persistent vector, incorporating the ideas we discussed.”</p>
<p>@@@</p>
<p>“I’ll work on the map implementation,” Elena offered.</p>
<p>“I’ll develop the sequence abstractions,” Raj said.</p>
<p>“And I’ll flesh out the overall architecture and documentation,” Alex concluded. “Let’s reconvene in a few days to share our progress.”</p>
<p>As they signed off, Alex felt a sense of purpose he hadn’t experienced in years. This project wasn’t just about code, it was about legacy, about passing on a way of thinking that had served him well throughout his career. It was about building a bridge between the elegant abstractions of Clojure and the bare-metal constraints of embedded systems.</p>
<p>He opened a new file and began typing:</p>
<div class="sourceClojure">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode clojure code-with-copy"><code class="sourceCode clojure"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>// Cljonic Design Principles</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>// <span class="fl">1.</span> Immutability by default</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>// <span class="fl">2.</span> Pure functions where possible</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>// <span class="fl">3.</span> Explicit state transitions</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>// <span class="fl">4.</span> No dynamic allocation</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>// <span class="fl">5.</span> No exceptions</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>// <span class="fl">6.</span> Bounded collections</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>// <span class="fl">7.</span> Default values instead of errors</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>// <span class="fl">8.</span> constexpr everything</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>// <span class="fl">9.</span> Header-only implementation</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>// <span class="fl">10.</span> Simple, understandable API</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Ten principles. A foundation to build upon. Alex saved the file and leaned back in his chair, looking out at the snow-covered landscape. This project would be his way of giving back to the programming community, of sharing what he’d learned over a lifetime of coding.</p>
<p>The phone rang, interrupting his thoughts. It was his daughter.</p>
<p>“Dad, are you still coming for dinner tonight? The kids have been asking about you all day.”</p>
<p>“Of course,” Alex said, smiling. “Wouldn’t miss it for the world.”</p>
<p>“You’re not working on another project, are you? You promised to take it easier after the heart scare last year.”</p>
<p>“Just a small one,” Alex admitted. “Nothing stressful.”</p>
<p>“Dad…”</p>
<p>“It’s a good one, sweetheart. Something meaningful. I’ll tell you about it tonight.”</p>
<p>After hanging up, Alex turned back to his computer. He had a few hours before dinner, enough time to flesh out the architecture document. As he typed, he found himself thinking about the generational divide in programming. His grandchildren would grow up in a world so different from the one he’d known, a world of neural networks, quantum computing, and programming languages that might make even Clojure look primitive.</p>
<p>But some principles were timeless. Immutability. Simplicity. Elegance. These were the ideas he wanted to pass on, not just to his team, but to future generations of programmers.</p>
<hr>
<p>Over the next few days, the team made remarkable progress. Kai’s implementation of PersistentVector had evolved significantly:</p>
<div class="sourceClojure">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode clojure code-with-copy"><code class="sourceCode clojure"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>template &lt;typename T, size_t MaxSize <span class="kw">=</span> CLJONIC_COLLECTION_MAXIMUM_ELEMENT_COUNT&gt;</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PersistentVector {</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>private:</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> VectorImpl {</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        std<span class="at">::array</span>&lt;T, MaxSize&gt; elements<span class="co">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        size_t <span class="kw">count</span> <span class="kw">=</span> <span class="dv">0</span><span class="co">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    }<span class="co">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    VectorImpl impl<span class="co">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>public:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    constexpr PersistentVector() <span class="kw">=</span> default<span class="co">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    // Private constructor <span class="kw">for</span> creating from an existing implementation</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    constexpr explicit PersistentVector(const VectorImpl&amp; impl) : impl(impl) {}</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    // Create a new <span class="kw">vector</span> with an additional <span class="kw">element</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    constexpr PersistentVector&lt;T, MaxSize&gt; <span class="kw">conj</span>(const T&amp; <span class="kw">element</span>) const {</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (impl.<span class="kw">count</span> <span class="kw">&gt;=</span> MaxSize) {</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            return *this<span class="co">; // Full, return unchanged</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        VectorImpl new_impl <span class="kw">=</span> impl<span class="co">;</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        new_impl.elements[new_impl.count++] <span class="kw">=</span> <span class="kw">element</span><span class="co">;</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        return PersistentVector&lt;T, MaxSize&gt;(new_impl)<span class="co">;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    // Get <span class="kw">element</span> at <span class="kw">index</span>, <span class="kw">or</span> default <span class="kw">if</span> out of <span class="kw">range</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    constexpr T <span class="kw">nth</span>(size_t <span class="kw">index</span>, T default_value <span class="kw">=</span> T{}) const {</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (<span class="kw">index</span> <span class="kw">&gt;=</span> impl.<span class="kw">count</span>) {</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>            return default_value<span class="co">;</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>        return impl.elements[<span class="kw">index</span>]<span class="co">;</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    // Return a new <span class="kw">vector</span> with <span class="kw">element</span> at <span class="kw">index</span> replaced</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    constexpr PersistentVector&lt;T, MaxSize&gt; <span class="kw">assoc</span>(size_t <span class="kw">index</span>, const T&amp; new_value) const {</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (<span class="kw">index</span> <span class="kw">&gt;=</span> impl.<span class="kw">count</span>) {</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>            return *this<span class="co">; // Out of bounds, return unchanged</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>        VectorImpl new_impl <span class="kw">=</span> impl<span class="co">;</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>        new_impl.elements[<span class="kw">index</span>] <span class="kw">=</span> new_value<span class="co">;</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>        return PersistentVector&lt;T, MaxSize&gt;(new_impl)<span class="co">;</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    // Execute a function <span class="kw">for</span> each <span class="kw">element</span> (immutable)</span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    template &lt;typename F&gt;</span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>    constexpr void each(F&amp;&amp; f) const {</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (size_t i <span class="kw">=</span> <span class="dv">0</span><span class="co">; i &lt; impl.count; ++i) {</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>            f(impl.elements[i])<span class="co">;</span></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>    // Transform each <span class="kw">element</span> <span class="kw">and</span> return a new <span class="kw">vector</span></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>    template &lt;typename F&gt;</span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>    constexpr auto <span class="kw">map</span>(F&amp;&amp; f) const {</span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>        using R <span class="kw">=</span> std<span class="at">::invoke</span>_result_t&lt;F, T&gt;<span class="co">;</span></span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>        PersistentVector&lt;R, MaxSize&gt; result<span class="co">;</span></span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (size_t i <span class="kw">=</span> <span class="dv">0</span><span class="co">; i &lt; impl.count; ++i) {</span></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a>            result <span class="kw">=</span> result.<span class="kw">conj</span>(f(impl.elements[i]))<span class="co">;</span></span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a>        return result<span class="co">;</span></span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a>    // Filter elements <span class="kw">and</span> return a new <span class="kw">vector</span></span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a>    template &lt;typename F&gt;</span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a>    constexpr PersistentVector&lt;T, MaxSize&gt; <span class="kw">filter</span>(F&amp;&amp; pred) const {</span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a>        PersistentVector&lt;T, MaxSize&gt; result<span class="co">;</span></span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (size_t i <span class="kw">=</span> <span class="dv">0</span><span class="co">; i &lt; impl.count; ++i) {</span></span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> (pred(impl.elements[i])) {</span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a>                result <span class="kw">=</span> result.<span class="kw">conj</span>(impl.elements[i])<span class="co">;</span></span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a>        return result<span class="co">;</span></span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a>    constexpr size_t size() const {</span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a>        return impl.<span class="kw">count</span><span class="co">;</span></span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a>    constexpr bool <span class="kw">empty</span>() const {</span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a>        return impl.<span class="kw">count</span> <span class="kw">==</span> <span class="dv">0</span><span class="co">;</span></span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a>    // First <span class="kw">element</span>, <span class="kw">or</span> default <span class="kw">if</span> <span class="kw">empty</span></span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a>    constexpr T <span class="kw">first</span>(T default_value <span class="kw">=</span> T{}) const {</span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a>        return <span class="kw">empty</span>() ? default_value : impl.elements[<span class="dv">0</span>]<span class="co">;</span></span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a>    // All but the <span class="kw">first</span> <span class="kw">element</span></span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a>    constexpr PersistentVector&lt;T, MaxSize&gt; <span class="kw">rest</span>() const {</span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (<span class="kw">empty</span>()) {</span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a>            return *this<span class="co">;</span></span>
<span id="cb9-95"><a href="#cb9-95" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-96"><a href="#cb9-96" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-97"><a href="#cb9-97" aria-hidden="true" tabindex="-1"></a>        PersistentVector&lt;T, MaxSize&gt; result<span class="co">;</span></span>
<span id="cb9-98"><a href="#cb9-98" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (size_t i <span class="kw">=</span> <span class="dv">1</span><span class="co">; i &lt; impl.count; ++i) {</span></span>
<span id="cb9-99"><a href="#cb9-99" aria-hidden="true" tabindex="-1"></a>            result <span class="kw">=</span> result.<span class="kw">conj</span>(impl.elements[i])<span class="co">;</span></span>
<span id="cb9-100"><a href="#cb9-100" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-101"><a href="#cb9-101" aria-hidden="true" tabindex="-1"></a>        return result<span class="co">;</span></span>
<span id="cb9-102"><a href="#cb9-102" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-103"><a href="#cb9-103" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-104"><a href="#cb9-104" aria-hidden="true" tabindex="-1"></a>    // Reduce to a single value</span>
<span id="cb9-105"><a href="#cb9-105" aria-hidden="true" tabindex="-1"></a>    template &lt;typename Acc, typename F&gt;</span>
<span id="cb9-106"><a href="#cb9-106" aria-hidden="true" tabindex="-1"></a>    constexpr Acc <span class="kw">reduce</span>(F&amp;&amp; f, Acc initial) const {</span>
<span id="cb9-107"><a href="#cb9-107" aria-hidden="true" tabindex="-1"></a>        Acc result <span class="kw">=</span> initial<span class="co">;</span></span>
<span id="cb9-108"><a href="#cb9-108" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (size_t i <span class="kw">=</span> <span class="dv">0</span><span class="co">; i &lt; impl.count; ++i) {</span></span>
<span id="cb9-109"><a href="#cb9-109" aria-hidden="true" tabindex="-1"></a>            result <span class="kw">=</span> f(result, impl.elements[i])<span class="co">;</span></span>
<span id="cb9-110"><a href="#cb9-110" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb9-111"><a href="#cb9-111" aria-hidden="true" tabindex="-1"></a>        return result<span class="co">;</span></span>
<span id="cb9-112"><a href="#cb9-112" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-113"><a href="#cb9-113" aria-hidden="true" tabindex="-1"></a>}<span class="co">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Elena had made similar progress on PersistentMap:</p>
<div class="sourceClojure">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode clojure code-with-copy"><code class="sourceCode clojure"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>template &lt;typename K, typename V, size_t MaxSize <span class="kw">=</span> CLJONIC_COLLECTION_MAXIMUM_ELEMENT_COUNT&gt;</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PersistentMap {</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>private:</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Entry {</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        K <span class="kw">key</span><span class="co">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        V value<span class="co">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        constexpr bool operator==(const K&amp; other_key) const {</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            return <span class="kw">key</span> <span class="kw">==</span> other_key<span class="co">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    }<span class="co">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> MapImpl {</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        std<span class="at">::array</span>&lt;Entry, MaxSize&gt; entries<span class="co">;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        size_t <span class="kw">count</span> <span class="kw">=</span> <span class="dv">0</span><span class="co">;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    }<span class="co">;</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    MapImpl impl<span class="co">;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    // Find <span class="kw">index</span> of <span class="kw">key</span>, <span class="kw">or</span> -<span class="dv">1</span> <span class="kw">if</span> <span class="kw">not</span> found</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    constexpr <span class="kw">int</span> find_index(const K&amp; <span class="kw">key</span>) const {</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (size_t i <span class="kw">=</span> <span class="dv">0</span><span class="co">; i &lt; impl.count; ++i) {</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> (impl.entries[i].<span class="kw">key</span> <span class="kw">==</span> <span class="kw">key</span>) {</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>                return static_cast&lt;int&gt;(i)<span class="co">;</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        return -<span class="dv">1</span><span class="co">;</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>public:</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    constexpr PersistentMap() <span class="kw">=</span> default<span class="co">;</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>    // Private constructor <span class="kw">for</span> creating from an existing implementation</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    constexpr explicit PersistentMap(const MapImpl&amp; impl) : impl(impl) {}</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    // Associate a <span class="kw">key</span> with a value, returning a new <span class="kw">map</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>    constexpr PersistentMap&lt;K, V, MaxSize&gt; <span class="kw">assoc</span>(const K&amp; <span class="kw">key</span>, const V&amp; value) const {</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">int</span> idx <span class="kw">=</span> find_index(<span class="kw">key</span>)<span class="co">;</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>        MapImpl new_impl <span class="kw">=</span> impl<span class="co">;</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (idx <span class="kw">&gt;=</span> <span class="dv">0</span>) {</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>            // Update existing entry</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>            new_impl.entries[idx].value <span class="kw">=</span> value<span class="co">;</span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>        } else <span class="kw">if</span> (impl.<span class="kw">count</span> <span class="kw">&lt;</span> MaxSize) {</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>            // Add new entry</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>            new_impl.entries[new_impl.<span class="kw">count</span>] <span class="kw">=</span> {<span class="kw">key</span>, value}<span class="co">;</span></span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>            new_impl.count++<span class="co">;</span></span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a>        return PersistentMap&lt;K, V, MaxSize&gt;(new_impl)<span class="co">;</span></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>    // Get value <span class="kw">for</span> <span class="kw">key</span>, <span class="kw">or</span> default <span class="kw">if</span> <span class="kw">not</span> found</span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a>    constexpr V <span class="kw">get</span>(const K&amp; <span class="kw">key</span>, V default_value <span class="kw">=</span> V{}) const {</span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a>        <span class="kw">int</span> idx <span class="kw">=</span> find_index(<span class="kw">key</span>)<span class="co">;</span></span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (idx <span class="kw">&gt;=</span> <span class="dv">0</span>) {</span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a>            return impl.entries[idx].value<span class="co">;</span></span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a>        return default_value<span class="co">;</span></span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a>    // Check <span class="kw">if</span> <span class="kw">key</span> exists</span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a>    constexpr bool contains(const K&amp; <span class="kw">key</span>) const {</span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true" tabindex="-1"></a>        return find_index(<span class="kw">key</span>) <span class="kw">&gt;=</span> <span class="dv">0</span><span class="co">;</span></span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-67"><a href="#cb10-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-68"><a href="#cb10-68" aria-hidden="true" tabindex="-1"></a>    // Remove a <span class="kw">key</span>, returning a new <span class="kw">map</span></span>
<span id="cb10-69"><a href="#cb10-69" aria-hidden="true" tabindex="-1"></a>    constexpr PersistentMap&lt;K, V, MaxSize&gt; <span class="kw">dissoc</span>(const K&amp; <span class="kw">key</span>) const {</span>
<span id="cb10-70"><a href="#cb10-70" aria-hidden="true" tabindex="-1"></a>        <span class="kw">int</span> idx <span class="kw">=</span> find_index(<span class="kw">key</span>)<span class="co">;</span></span>
<span id="cb10-71"><a href="#cb10-71" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (idx <span class="kw">&lt;</span> <span class="dv">0</span>) {</span>
<span id="cb10-72"><a href="#cb10-72" aria-hidden="true" tabindex="-1"></a>            return *this<span class="co">; // Key not found, return unchanged</span></span>
<span id="cb10-73"><a href="#cb10-73" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb10-74"><a href="#cb10-74" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-75"><a href="#cb10-75" aria-hidden="true" tabindex="-1"></a>        MapImpl new_impl<span class="co">;</span></span>
<span id="cb10-76"><a href="#cb10-76" aria-hidden="true" tabindex="-1"></a>        new_impl.<span class="kw">count</span> <span class="kw">=</span> impl.<span class="kw">count</span> <span class="kw">-</span> <span class="dv">1</span><span class="co">;</span></span>
<span id="cb10-77"><a href="#cb10-77" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-78"><a href="#cb10-78" aria-hidden="true" tabindex="-1"></a>        // Copy entries before the removed one</span>
<span id="cb10-79"><a href="#cb10-79" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (<span class="kw">int</span> i <span class="kw">=</span> <span class="dv">0</span><span class="co">; i &lt; idx; ++i) {</span></span>
<span id="cb10-80"><a href="#cb10-80" aria-hidden="true" tabindex="-1"></a>            new_impl.entries[i] <span class="kw">=</span> impl.entries[i]<span class="co">;</span></span>
<span id="cb10-81"><a href="#cb10-81" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb10-82"><a href="#cb10-82" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-83"><a href="#cb10-83" aria-hidden="true" tabindex="-1"></a>        // Copy entries after the removed one</span>
<span id="cb10-84"><a href="#cb10-84" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (size_t i <span class="kw">=</span> idx <span class="kw">+</span> <span class="dv">1</span><span class="co">; i &lt; impl.count; ++i) {</span></span>
<span id="cb10-85"><a href="#cb10-85" aria-hidden="true" tabindex="-1"></a>            new_impl.entries[i <span class="kw">-</span> <span class="dv">1</span>] <span class="kw">=</span> impl.entries[i]<span class="co">;</span></span>
<span id="cb10-86"><a href="#cb10-86" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb10-87"><a href="#cb10-87" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-88"><a href="#cb10-88" aria-hidden="true" tabindex="-1"></a>        return PersistentMap&lt;K, V, MaxSize&gt;(new_impl)<span class="co">;</span></span>
<span id="cb10-89"><a href="#cb10-89" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-90"><a href="#cb10-90" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-91"><a href="#cb10-91" aria-hidden="true" tabindex="-1"></a>    // Execute a function <span class="kw">for</span> each key-value pair (immutable)</span>
<span id="cb10-92"><a href="#cb10-92" aria-hidden="true" tabindex="-1"></a>    template &lt;typename F&gt;</span>
<span id="cb10-93"><a href="#cb10-93" aria-hidden="true" tabindex="-1"></a>    constexpr void each(F&amp;&amp; f) const {</span>
<span id="cb10-94"><a href="#cb10-94" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (size_t i <span class="kw">=</span> <span class="dv">0</span><span class="co">; i &lt; impl.count; ++i) {</span></span>
<span id="cb10-95"><a href="#cb10-95" aria-hidden="true" tabindex="-1"></a>            f(impl.entries[i].<span class="kw">key</span>, impl.entries[i].value)<span class="co">;</span></span>
<span id="cb10-96"><a href="#cb10-96" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb10-97"><a href="#cb10-97" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-98"><a href="#cb10-98" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-99"><a href="#cb10-99" aria-hidden="true" tabindex="-1"></a>    constexpr size_t size() const {</span>
<span id="cb10-100"><a href="#cb10-100" aria-hidden="true" tabindex="-1"></a>        return impl.<span class="kw">count</span><span class="co">;</span></span>
<span id="cb10-101"><a href="#cb10-101" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-102"><a href="#cb10-102" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-103"><a href="#cb10-103" aria-hidden="true" tabindex="-1"></a>    constexpr bool <span class="kw">empty</span>() const {</span>
<span id="cb10-104"><a href="#cb10-104" aria-hidden="true" tabindex="-1"></a>        return impl.<span class="kw">count</span> <span class="kw">==</span> <span class="dv">0</span><span class="co">;</span></span>
<span id="cb10-105"><a href="#cb10-105" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-106"><a href="#cb10-106" aria-hidden="true" tabindex="-1"></a>}<span class="co">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>And Raj had begun work on the sequence abstraction:</p>
<div class="sourceClojure">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode clojure code-with-copy"><code class="sourceCode clojure"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>// A <span class="kw">sequence</span> interface <span class="kw">for</span> C++</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>template &lt;typename T&gt;</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ISequence {</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>public:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    virtual <span class="at">~ISequence</span>() <span class="kw">=</span> default<span class="co">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    virtual bool <span class="kw">empty</span>() const <span class="kw">=</span> <span class="dv">0</span><span class="co">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    virtual T <span class="kw">first</span>(T default_value <span class="kw">=</span> T{}) const <span class="kw">=</span> <span class="dv">0</span><span class="co">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    virtual std<span class="at">::unique</span>_ptr&lt;ISequence&lt;T&gt;&gt; <span class="kw">rest</span>() const <span class="kw">=</span> <span class="dv">0</span><span class="co">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>}<span class="co">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>// A wrapper to make PersistentVector conform to ISequence</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>template &lt;typename T, size_t MaxSize&gt;</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VectorSequence : public ISequence&lt;T&gt; {</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>private:</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    PersistentVector&lt;T, MaxSize&gt; <span class="kw">vec</span><span class="co">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>public:</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    constexpr explicit VectorSequence(PersistentVector&lt;T, MaxSize&gt; v) : <span class="kw">vec</span>(std<span class="at">::move</span>(v)) {}</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    bool <span class="kw">empty</span>() const override {</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        return <span class="kw">vec</span>.<span class="kw">empty</span>()<span class="co">;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    T <span class="kw">first</span>(T default_value <span class="kw">=</span> T{}) const override {</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>        return <span class="kw">vec</span>.<span class="kw">first</span>(default_value)<span class="co">;</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    std<span class="at">::unique</span>_ptr&lt;ISequence&lt;T&gt;&gt; <span class="kw">rest</span>() const override {</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        return std<span class="at">::make</span>_unique&lt;VectorSequence&lt;T, MaxSize&gt;&gt;(<span class="kw">vec</span>.<span class="kw">rest</span>())<span class="co">;</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>}<span class="co">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>But when they reconvened, Raj had concerns.</p>
<p>“This sequence interface won’t work for embedded systems,” he said, his expression troubled. “I got carried away and forgot we can’t use virtual functions or <code>unique_ptr</code> because they rely on the heap.”</p>
<p>“That’s alright,” Alex said. “It’s a common mistake. We all fall back into our usual patterns. Let’s rethink our approach to sequences.”</p>
<p>“We could use static polymorphism instead,” Kai suggested. “C++ templates and concepts instead of runtime polymorphism.”</p>
<p>“Or we could just define sequence operations as free functions that work on our data structures,” Elena said. “Clojure’s sequence functions like <code>first</code>, <code>rest</code>, and <code>cons</code> are actually just functions that work on collections that satisfy the sequence abstraction.”</p>
<p>“I like that approach,” Alex said. “It’s simpler and more in line with how Clojure actually works. Let’s define a set of functions that operate on any type that provides the right operations.”</p>
<p>Raj nodded, already rethinking his approach. “So instead of an interface, we define a concept, a set of requirements that a type must satisfy to be considered a sequence.”</p>
<p>“Exactly,” Kai said. “And we can use C++20’s actual <code>concept</code> feature to enforce that.”</p>
<p>They worked together to redefine the sequence abstraction:</p>
<div class="sourceClojure">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode clojure code-with-copy"><code class="sourceCode clojure"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>// A concept that defines what it means to be a <span class="kw">sequence</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>template &lt;typename T&gt;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>concept Sequence <span class="kw">=</span> requires(T t, typename T<span class="at">::value</span>_type default_val) {</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    { t.<span class="kw">empty</span>() } <span class="kw">-&gt;</span> std<span class="at">::convertible</span>_to&lt;bool&gt;<span class="co">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    { t.<span class="kw">first</span>(default_val) } <span class="kw">-&gt;</span> std<span class="at">::convertible</span>_to&lt;typename T<span class="at">::value</span>_type&gt;<span class="co">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    { t.<span class="kw">rest</span>() } <span class="kw">-&gt;</span> std<span class="at">::convertible</span>_to&lt;T&gt;<span class="co">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>}<span class="co">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>// Free functions that work on any Sequence</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>template &lt;typename S&gt;</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>requires Sequence&lt;S&gt;</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>constexpr auto <span class="kw">first</span>(const S&amp; <span class="kw">seq</span>) {</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    return <span class="kw">seq</span>.<span class="kw">first</span>()<span class="co">;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>template &lt;typename S&gt;</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>requires Sequence&lt;S&gt;</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>constexpr auto first_or(const S&amp; <span class="kw">seq</span>, typename S<span class="at">::value</span>_type default_val) {</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    return <span class="kw">seq</span>.<span class="kw">first</span>(default_val)<span class="co">;</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>template &lt;typename S&gt;</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>requires Sequence&lt;S&gt;</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>constexpr auto <span class="kw">rest</span>(const S&amp; <span class="kw">seq</span>) {</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    return <span class="kw">seq</span>.<span class="kw">rest</span>()<span class="co">;</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>template &lt;typename S, typename F&gt;</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>requires Sequence&lt;S&gt;</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>constexpr void each(const S&amp; <span class="kw">seq</span>, F&amp;&amp; f) {</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (<span class="kw">seq</span>.<span class="kw">empty</span>()) return<span class="co">;</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>    f(<span class="kw">seq</span>.<span class="kw">first</span>())<span class="co">;</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    each(<span class="kw">seq</span>.<span class="kw">rest</span>(), std<span class="at">::forward</span>&lt;F&gt;(f))<span class="co">;</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>template &lt;typename S, typename F, typename Acc&gt;</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>requires Sequence&lt;S&gt;</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>constexpr auto <span class="kw">reduce</span>(const S&amp; <span class="kw">seq</span>, F&amp;&amp; f, Acc initial) {</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (<span class="kw">seq</span>.<span class="kw">empty</span>()) return initial<span class="co">;</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>    Acc next_acc <span class="kw">=</span> f(initial, <span class="kw">seq</span>.<span class="kw">first</span>())<span class="co">;</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>    return <span class="kw">reduce</span>(<span class="kw">seq</span>.<span class="kw">rest</span>(), std<span class="at">::forward</span>&lt;F&gt;(f), next_acc)<span class="co">;</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>template &lt;typename S, typename F&gt;</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>requires Sequence&lt;S&gt;</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>constexpr auto <span class="kw">map</span>(const S&amp; <span class="kw">seq</span>, F&amp;&amp; f) {</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (<span class="kw">seq</span>.<span class="kw">empty</span>()) {</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>        return S{}<span class="co">;</span></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>    using R <span class="kw">=</span> std<span class="at">::invoke</span>_result_t&lt;F, typename S<span class="at">::value</span>_type&gt;<span class="co">;</span></span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a>    // This <span class="kw">is</span> a simplified implementation <span class="kw">-</span> a real one would need to <span class="kw">handle</span> different return types</span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>    S result <span class="kw">=</span> S{}.<span class="kw">conj</span>(f(<span class="kw">seq</span>.<span class="kw">first</span>()))<span class="co">;</span></span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a>    return <span class="kw">concat</span>(result, <span class="kw">map</span>(<span class="kw">seq</span>.<span class="kw">rest</span>(), std<span class="at">::forward</span>&lt;F&gt;(f)))<span class="co">;</span></span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Alex sat back in his chair, a satisfied smile spreading across his face. They had done it—laid the groundwork for Cljonic. The basic data structures and sequence operations were taking shape, and the design principles were solid.</p>
<p>He knew they still had a long way to go. They needed to implement more data structures, refine the API, write comprehensive documentation, and test everything extensively. But they had a foundation to build on, a vision to guide them, and a team with the perfect mix of expertise.</p>
<p>As he closed his laptop and prepared to head to his daughter’s for dinner, Alex felt a quiet pride. This project wasn’t just about code, it was about bridging worlds, about bringing the beauty of functional programming to a domain that desperately needed it. It was about passing on a way of thinking to the next generation of programmers.</p>
<p>The snow continued to fall outside, each flake a unique pattern, yet part of a greater whole. Like the parentheses in Clojure, they contained worlds within worlds, structures within structures. And like the C++ he’d been writing, they were bound by constraints that somehow made them more beautiful, not less.</p>
<p>Alex grabbed his coat and headed out the door. The Cljonic journey was just beginning, but already it felt right. It felt like coming home.</p>
<hr>
<p><em>End of Chapter 1</em></p>
<div style="margin-top:2em;text-align:center;"><p>❧</p></div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./index.html" class="pagination-link" aria-label="Parens From The Past">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Parens From The Past</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./chapter_02.html" class="pagination-link" aria-label="chapter_02.html">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">chapter_02.html</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>